# -*- coding: utf-8 -*-
"""ML Music - YouTube - Audio Feature Extraction Pipeline

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kj7w1rG-yPOUvGEa-Vremo8l5beDblAS

## Setup
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# # https://pytube.io/en/latest/index.html
# # https://librosa.org/doc/main/generated/librosa.feature.mfcc.html
# # https://pysoundfile.readthedocs.io/en/latest/#module-soundfile
# 
# !pip install pytube librosa soundfile

import warnings

warnings.filterwarnings("ignore")

!pip list

"""### Google Drive"""

from google.colab import drive

drive.mount('/content/drive')

import os

# you might need to update the path below, or create a shortcut to the path below
DATASET_PATH = '/content/drive/MyDrive/Research/DS Research Shared 2023/data/ml_music_2023'

print(DATASET_PATH)
assert os.path.isdir(DATASET_PATH)

CHANNELS_DIRPATH = os.path.join(DATASET_PATH, "youtube_channels")
print(os.listdir(CHANNELS_DIRPATH))

"""## Helpers"""

def split_into_batches(my_list, batch_size=10_000):
    """Splits a list into evenly sized batches"""
    # h/t: https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks
    for i in range(0, len(my_list), batch_size):
        yield my_list[i : i + batch_size]


result = list(split_into_batches([1,2,3,4,5,6,7], batch_size=3))
print(result)
assert result == [[1,2,3], [4,5,6], [7]]

#@title


#def parse_video_features(video):
#    return {
#
#        'video_id': video.video_id,
#        'channel_id': video.channel_id,
#        'author': video.author,
#
#        'title': video.title,
#        'description': video.description,
#
#        'keywords': video.keywords,
#        'length': video.length,
#        'publish_date': video.publish_date,
#        'rating': video.rating,        
#        'views': video.views,
#
#        'channel_url': video.channel_url,
#        'thumbnail_url': video.thumbnail_url,
#        'watch_url': video.watch_url,
#
#        #'caption_tracks': video.caption_tracks,
#        #'captions': video.captions,
#
#        #'age_restricted': video.age_restricted,
#        #'allow_oauth_cache': video.allow_oauth_cache,
#        #'bypass_age_gate': video.bypass_age_gate,
#        #'check_availability': video.check_availability,
#        #'embed_html': video.embed_html,
#        #'embed_url': video.embed_url,
#        #'fmt_streams': video.fmt_streams,
#        #'from_id': video.from_id,
#        #'initial_data': video.initial_data,
#        #'js': video.js,
#        #'js_url': video.js_url,
#        #'metadata': video.metadata,
#        #'register_on_complete_callback': video.register_on_complete_callback,
#        #'register_on_progress_callback': video.register_on_progress_callback,
#        #'stream_monostate': video.stream_monostate,
#        #'streaming_data': video.streaming_data,
#        #'streams': video.streams,
#        #'use_oauth': video.use_oauth,
#        #'watch_html': video.watch_html,
#        #'vid_info': video.vid_info,
#    }
#

def parse_video_id(video_url):
    """assumes all video urls are cleanly formatted like https://www.youtube.com/watch?v=ABC123"""
    return video_url.split("?v=")[-1]


assert parse_video_id("https://www.youtube.com/watch?v=0dzZXpf7sSQ") == "0dzZXpf7sSQ"

def parse_audio_filename(audio_filepath):
    """
    Param audio_filepath like: "/content/Maggie Rogers - The Knife (Live On Austin City Limits).mp4"
    """
    return audio_filepath.split("/content/")[-1]


assert parse_audio_filename("/content/Maggie Rogers - The Knife (Live On Austin City Limits).mp4") == "Maggie Rogers - The Knife (Live On Austin City Limits).mp4"

"""## YouTube Audio Pipeline"""

661_500 / 30

from functools import cached_property
from pytube import YouTube

import librosa
from librosa.feature import mfcc, chroma_stft, melspectrogram, spectral_contrast, tonnetz
from librosa.effects import harmonic
import numpy as np

from IPython.display import display, Audio, Image


class YouTubePipeline:

    def __init__(self, video_url="https://www.youtube.com/watch?v=q6HiZIQoLSU", audio_filepath=None):
        self.video_url = video_url

        # SCRAPE YOUTUBE
        self.video = YouTube(self.video_url)
        #print(self.video.channel_url, self.video.video_id, self.video.title)

        # DOWNLOAD AUDIO FILE:
        self.audio_streams = self.video.streams.filter(only_audio=True, file_extension='mp4').order_by("abr").asc()
        download_params = {"skip_existing": True}
        if audio_filepath:
            download_params["output_path"] = audio_filepath
        self.audio_filepath = self.audio_streams.first().download(**download_params)
        #print("AUDIO FILEPATH:", self.audio_filepath) # "/content/Maggie Rogers - Say It (Live On The Tonight Show Starring Jimmy Fallon  2019).mp4"

        # EXTRACT AUDIO DATA:
        self.audio, self.sample_rate = librosa.load(self.audio_filepath)
        #print("SAMPLE RATE:", self.sample_rate)

    @property
    def sr(self):
        """shorthand alias for the sample rate"""
        return self.sample_rate

    def play_in_colab(self, audio_data=None, image=True):
        audio_data = audio_data or self.audio_filepath
        if image:
            display(Image(url=self.video.thumbnail_url, height=250))
        display(Audio(audio_data, autoplay=False, rate=self.sr)) # rate only necessary when passing custom audio data

    #
    # AUDIO FEATURES
    #

    def mfcc(self, n_mfcc=12, audio_data=None):
        """audio_data (np.array)"""
        # if no data is specified, use the entire audio:
        if not isinstance(audio_data, np.ndarray):
            audio_data = self.audio
        
        #print(f"MFCC ({n_mfcc})...")
        return mfcc(y=audio_data, sr=self.sr, n_mfcc=n_mfcc)

    #def chroma_stft(self):
    #    print("CHROMA STFT...")
    #    return chroma_stft(y=audio_data, sr=self.sr)

    #def melspectrogram(self, audio_data=None):
    #    print("MELSPECTROGRAM...")
    #    return melspectrogram(y=audio_data, sr=self.sr)

    #def spectral_contrast(self, audio_data=None):
    #    print("SPECTRAL CONTRAST...")
    #    return spectral_contrast(y=audio_data, sr=self.sr)

    #def tonnetz(self, audio_data=None):
    #    print("TONNETZ...")
    #    return tonnetz(y=harmonic(audio_data), sr=self.sr)

    #
    # TRACK CUTTING
    #

    def tracks(self, track_length_seconds=30, discard_last=True):
        """Returns equal sized tracks of the given duration.
            Discards the last track, because it will have a different duration.
        """
        
        track_length = track_length_seconds * self.sr
        #print("TRACK LENGTH:", track_length) #> 661_500 for 30s with a sample rate of 22_050 per second 
        
        all_tracks = list(split_into_batches(self.audio.tolist(), batch_size=track_length))
        #print(f"ALL TRACKS ({len(all_tracks)}):", [len(t) for t in all_tracks])

        if discard_last:
            return all_tracks[0:-1] # not including the last item in the list
        else:
            return all_tracks

"""### Example Video Collection"""

ytp = YouTubePipeline()
ytp.play_in_colab()

ytp.audio_filepath

import soundfile as sf

#sf.available_subtypes("MP3")
#sf.available_formats()

tracks = ytp.tracks()

for i, track_30s in enumerate(tracks):
    track_name = f"track_{i+1}.mp3"

    print("--------------------")
    print(ytp.video.title)
    print("...", track_name, len(track_30s))
    ytp.play_in_colab(track_30s, image=False)

    # https://pysoundfile.readthedocs.io/en/latest/#soundfile.write
    sf.write(track_name, track_30s, samplerate=ytp.sr)

track30 = tracks[0]
len(track30)

video_mfcc = ytp.mfcc()
print(type(video_mfcc), video_mfcc.shape)

track_array = np.array(track30)
isinstance(track_array, np.ndarray)

#np.array(track30) or "five"

track_mfcc = ytp.mfcc(audio_data=np.array(track30))

print(type(track_mfcc), track_mfcc.shape)

track_mfcc.shape[0]

from pandas import DataFrame

n_mfcc = track_mfcc.shape[0]
mfcc_cols = [f"mfcc_{i}" for i in range(1, n_mfcc+1)]
mfcc_df = DataFrame(track_mfcc.T, columns=mfcc_cols)
mfcc_df

"""### Multiple Video Collection"""

import os
import shutil
from time import sleep

from pytube.exceptions import PytubeError
import soundfile as sf
from pandas import DataFrame


#N_MFCC = 20
NUMS_MFCC = [2,3,12,20]

VIDEO_URLS = {    
    "maggie_rogers":[
        "https://www.youtube.com/watch?v=0dzZXpf7sSQ", # say it
        "https://www.youtube.com/watch?v=q6HiZIQoLSU", # knife
        "https://www.youtube.com/watch?v=bR1d8l92Q8Q", # fallingwater
        "https://www.youtube.com/watch?v=gigJjgPThYA", # overdrive
        "https://www.youtube.com/watch?v=MSFjYe54uv4", # light on
        "https://www.youtube.com/watch?v=yaXAMuhIe7Y", # give a little
        "https://www.youtube.com/watch?v=iKYxMnW7bgs", # love you for a long time
        "https://www.youtube.com/watch?v=IHi5jq2P_Zk", # split stones
        "https://www.youtube.com/watch?v=19ItfuE585w", # alaska (acoustic)
    ],
    "john_mayer": [ 
        # BATTLE STUDIES
        "https://www.youtube.com/watch?v=GeCClzNCfcA", # John Mayer - Heartbreak Warfare (Official Music Video)
        "https://www.youtube.com/watch?v=FgK7vTaJCEM", # All We Ever Do Is Say Goodbye
        "https://www.youtube.com/watch?v=zr6lp-45bOQ", # Half of My Heart
        "https://www.youtube.com/watch?v=KoLc_6BmyTc", # John Mayer - Perfectly Lonely (Official Audio)
        "https://www.youtube.com/watch?v=VDrZww-uHZU", # Assassin
        "https://www.youtube.com/watch?v=5zqRVADxYpM", # Crossroads
        "https://www.youtube.com/watch?v=E3ZAc6WlPYg", # War of My Life
        "https://www.youtube.com/watch?v=Nt-jb5JHWB8", # Edge of Desire
        "https://www.youtube.com/watch?v=cZVT8Zg0YwE", # Do You Know Me
        "https://www.youtube.com/watch?v=LaG0keIFX6o" # Friends, Lovers or Nothing
        # CONTINUUM    
    ],
    # https://www.youtube.com/channel/UCsdXkstc8jFC3zpMYdEz_zA
    "chris_stapleton":[
         # VOL 2
        "https://www.youtube.com/watch?v=sI0TeFf6uD8", # Chris Stapleton - Broken Halos (Official Audio)
        "https://www.youtube.com/watch?v=7IhQrVeXn2M", # Chris Stapleton - I Was Wrong (Official Audio)
        "https://www.youtube.com/watch?v=k4oGoiN4JtM", # Chris Stapleton - Without Your Love (Official Audio)
        "https://www.youtube.com/watch?v=m_TsUb0T95E", # Chris Stapleton - Death Row (Official Audio)
        # VOL 1
        "https://www.youtube.com/watch?v=MPoN-FNB2V8", # Chris Stapleton - Millionaire (Official Audio)
        # STARTING OVER
        "https://www.youtube.com/watch?v=wilhfxYfqfc", # You Should Probably Leave
        "https://www.youtube.com/watch?v=UIAo_Awfs-E", # Cold
        "https://www.youtube.com/watch?v=A3svABDnmio", # Chris Stapleton - Starting Over (Official Music Video)
        "https://www.youtube.com/watch?v=WbBt5qDoCAs", # Chris Stapleton - Devil Always Made Me Think Twice (Official Audio)
        "https://www.youtube.com/watch?v=jsE_zp_4vyo", # Chris Stapleton - Joy Of My Life (Official Audio)
        "https://www.youtube.com/watch?v=EzqskyzdWJw", # Chris Stapleton - Hillbilly Blood (Official Audio)
        # TRAVELER
        "https://www.youtube.com/watch?v=l6_w3887Rwo", # Tennessee Whiskey
    ]
    # morgan whalen
    # taylor swift
    # frank sinatra
    # adele
    # sam smith
    # jay z
    # justin beiber
    #"ariana_grande":
    # beyonce
    # bts
}


for channel_dirname, video_urls in VIDEO_URLS.items():
    print("CHANNEL:", channel_dirname)

    channel_dirpath = os.path.join(CHANNELS_DIRPATH, channel_dirname)
    print(channel_dirpath)
    os.makedirs(channel_dirpath, exist_ok=True)
                
    for video_url in video_urls:
        #video = YouTube(video_url)
        #result = parse_video_features(video)

        video_id = parse_video_id(video_url)
        #print(video_id)
        #expected_video_dirpath = os.path.join(channel_dirpath, video_id)
        #expected_audio_filepath = os.path.join(expected_video_dirpath, video_id)

        complete = False
        while not complete:
            try:

                ytp = YouTubePipeline(video_url=video_url)
                video_id = ytp.video.video_id
                print("-------------------")
                print("VIDEO:", video_id)
                
                video_dirpath = os.path.join(channel_dirpath, video_id)
                print(video_dirpath)
                os.makedirs(video_dirpath, exist_ok=True)
                
                audio_filename = parse_audio_filename(ytp.audio_filepath)
                audio_filepath = os.path.join(video_dirpath, audio_filename)
                shutil.copyfile(ytp.audio_filepath, audio_filepath)

                tracks_dirpath = os.path.join(video_dirpath, "tracks")
                os.makedirs(tracks_dirpath, exist_ok=True)

                #n_mfcc = N_MFCC
                #for n_mfcc in NUMS_MFCC:
                #    print(n_mfcc)
                #    mfcc_dirpath = os.path.join(video_dirpath, f"mfcc_{n_mfcc}")
                #    os.makedirs(mfcc_dirpath, exist_ok=True)
                #
                #    for i, track_30s in enumerate(ytp.tracks()):
                #        #ytp.play_in_colab(track_30s, image=False)
                #        track_name = f"track_{i+1}"
                #        track_filepath = os.path.join(tracks_dirpath, f"{track_name}.mp3")
                #        sf.write(track_filepath, track_30s, samplerate=ytp.sr)
                #
                #        # EXTRACT AUDIO FEATURES
                #        track_mfcc = ytp.mfcc(audio_data=np.array(track30), n_mfcc=n_mfcc)
                #        #n_mfcc = track_mfcc.shape[0]
                #        mfcc_cols = [f"mfcc_{i}" for i in range(1, n_mfcc+1)]
                #        mfcc_df = DataFrame(track_mfcc.T, columns=mfcc_cols)
                #        #print(mfcc_df.shape)
                #        track_mfcc_filepath = os.path.join(mfcc_dirpath, f"{track_name}.csv")
                #        mfcc_df.to_csv(track_mfcc_filepath)

                for i, track_30s in enumerate(ytp.tracks()):
                    #ytp.play_in_colab(track_30s, image=False)
                    track_name = f"track_{i+1}"
                    print(track_name)
                    track_filepath = os.path.join(tracks_dirpath, f"{track_name}.mp3")
                    sf.write(track_filepath, track_30s, samplerate=ytp.sr)

                    for n_mfcc in NUMS_MFCC:
                        print(n_mfcc)
                        mfcc_dirpath = os.path.join(video_dirpath, f"mfcc_{n_mfcc}")
                        os.makedirs(mfcc_dirpath, exist_ok=True)

                        # EXTRACT AUDIO FEATURES
                        track_mfcc = ytp.mfcc(audio_data=np.array(track_30s), n_mfcc=n_mfcc)
                        #n_mfcc = track_mfcc.shape[0]
                        mfcc_cols = [f"mfcc_{i}" for i in range(1, n_mfcc+1)]
                        mfcc_df = DataFrame(track_mfcc.T, columns=mfcc_cols)
                        #print(mfcc_df.shape)
                        track_mfcc_filepath = os.path.join(mfcc_dirpath, f"{track_name}.csv")
                        mfcc_df.to_csv(track_mfcc_filepath)

                complete = True
            except (PytubeError, KeyError) as err:
                print(err)
                print("OOPS PYTUBE ERROR TRY THIS ONE AGAIN:", video_id)
                sleep(5)
            
        sleep(2)
    
    print("DONE!")

















"""## Scratch Work"""

print(type(ytp.audio))
print(ytp.audio.shape)

audio_length = ytp.audio.shape[0]
audio_length_sec = audio_length / ytp.sample_rate
print(audio_length_sec / 60) # len_minutes

all_mfcc = ytp.mfcc(n_mfcc=20)
print(all_mfcc.shape)

signal = ytp.audio
display(Audio(signal, autoplay=False, rate=ytp.sr))

signal.shape

signal_list = signal.tolist()
print(len(signal_list))

display(Audio(signal_list[0:1_000_000], autoplay=False, rate=ytp.sr))

display(Audio(signal_list[0:661_500], autoplay=False, rate=ytp.sr))

"""Given a song with a sample rate of 22,050 signal length per second, we can cut a 30 second track using an interval that has a signal length of 661,500. 

This matches the characteristics of the GTZAN dataset.
"""

print("30 SECOND TRACKS!")

for track_30s in split_into_batches(ytp.audio.tolist(), batch_size=661_500):
    print("---------")
    print("SIZE:", len(track_30s))
    display(Audio(track_30s, autoplay=False, rate=ytp.sr))

"""We can discard the last track for each song, assuming it will be a different length. We will miss the finale of all the songs, which may be an impactful moment. But its probably OK for now."""





